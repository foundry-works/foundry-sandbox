#!/bin/bash
# Entrypoint script for credential isolation gateway
# Starts dnsmasq for DNS routing (as root) and Gunicorn bound to both TCP and Unix socket (as appuser)
#
# SECURITY: Implements startup synchronization barrier to ensure firewall rules
# are applied before accepting any connections.

set -e

# Runtime user for privilege dropping
RUN_USER="${GATEWAY_USER:-appuser}"

# Start dnsmasq for DNS routing (if configured)
# This allows the gateway to control DNS resolution for sandboxed containers
# dnsmasq binds to port 53 as root, then drops privileges to appuser
# via the user= and group= directives in dnsmasq.conf (generated by build-configs.sh)
if [ -f /etc/dnsmasq.conf ] && [ "${GATEWAY_ENABLE_DNS:-false}" = "true" ]; then
    if [ "$(id -u)" -eq 0 ]; then
        echo "Starting dnsmasq for DNS routing..."
        dnsmasq --keep-in-foreground &
        DNSMASQ_PID=$!
        echo "dnsmasq started with PID: ${DNSMASQ_PID}"
    else
        echo "WARNING: dnsmasq requires root privileges to bind port 53, skipping DNS routing"
        echo "To enable DNS routing, run the container with GATEWAY_ENABLE_DNS=true and as root"
    fi
else
    echo "DNS routing disabled (set GATEWAY_ENABLE_DNS=true to enable)"
fi

# Cleanup function for graceful shutdown
cleanup() {
    echo "Shutting down gateway services..."

    # Stop dnsmasq if running
    if [ -n "${DNSMASQ_PID:-}" ] && kill -0 "${DNSMASQ_PID}" 2>/dev/null; then
        echo "Stopping dnsmasq (PID: ${DNSMASQ_PID})..."
        kill -TERM "${DNSMASQ_PID}" 2>/dev/null || true
        wait "${DNSMASQ_PID}" 2>/dev/null || true
    fi

    echo "Gateway shutdown complete"
    exit 0
}

# Register cleanup handler for graceful shutdown
trap cleanup SIGTERM SIGINT SIGQUIT

# ==============================================================================
# SECURITY: Startup Synchronization Barrier
# ==============================================================================
# Ensure firewall rules are applied BEFORE accepting any connections.
# This prevents a race condition where malicious code could exfiltrate data
# during the startup window before iptables rules are in place.
#
# The firewall script (if run externally) should create the ready file.
# If running in standalone mode, we apply basic rules here.
# ==============================================================================

apply_startup_firewall() {
    echo "Applying startup firewall rules..."

    # Check if we have iptables capability
    if ! command -v iptables &>/dev/null; then
        echo "WARNING: iptables not available, skipping firewall rules"
        return 0
    fi

    # Check if we have NET_ADMIN capability (required for iptables)
    if ! iptables -L OUTPUT -n &>/dev/null 2>&1; then
        echo "WARNING: Cannot access iptables (missing NET_ADMIN?), skipping firewall rules"
        return 0
    fi

    # ===========================================================================
    # IMPORTANT: Gateway Container Firewall (Supplementary)
    # ===========================================================================
    # These rules provide basic egress filtering for the GATEWAY CONTAINER ONLY.
    # They are NOT the primary sandbox isolation mechanism.
    #
    # For sandbox isolation, network-firewall.sh MUST be run on sandbox
    # containers. That script:
    # - Sets DROP policy for OUTPUT chain
    # - Whitelists specific domains (GitHub, AI APIs, package registries)
    # - Blocks all other egress traffic
    #
    # This startup firewall only ensures:
    # - Loopback traffic works (for Unix socket communication)
    # - Established connections continue (for in-flight requests during restart)
    # - GitHub egress is allowed (for git proxy functionality)
    #
    # We intentionally do NOT set a DROP policy here because:
    # 1. The gateway needs outbound access to GitHub for proxying
    # 2. Sandbox isolation is enforced by network-firewall.sh on sandboxes
    # 3. DOCKER-USER chain rules (setup_docker_user_rules) block sandbox egress
    # ===========================================================================

    # Only apply if OUTPUT chain is empty (avoid double application)
    local rule_count
    rule_count=$(iptables -L OUTPUT -n 2>/dev/null | wc -l)
    if [ "$rule_count" -gt 2 ]; then
        echo "Firewall rules already applied (${rule_count} rules in OUTPUT)"
        return 0
    fi

    echo "  - Allowing loopback and established connections"
    iptables -A OUTPUT -o lo -j ACCEPT 2>/dev/null || true
    iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT 2>/dev/null || true

    echo "Gateway firewall rules applied (note: sandbox isolation requires network-firewall.sh)"
    return 0
}

# Apply firewall rules before starting any services
apply_startup_firewall

echo "Gateway firewall barrier complete"

# Start Gunicorn bound to TCP port only
# - TCP 8080: For all HTTP traffic (git operations + session management)
#
# Note: Unix socket binding was removed due to compatibility issues with
# Docker Desktop's fakeowner filesystem on Linux. Session management from
# the host now uses TCP via exposed port.
#
# IMPORTANT: Single-Worker Architecture Constraint
# ================================================
# The gateway uses --workers 1 because session state is stored in an
# in-memory Python dict (SESSIONS). Multiple workers would each have
# their own separate dict, causing session validation failures when
# requests land on different workers than where the session was created.
#
# Performance implications:
# - Single worker handles all requests sequentially (sync worker class)
# - Long-running git operations (clone, push) block other requests
# - Sufficient for sandbox environments with limited concurrent containers
#
# For high-scale deployments requiring multiple workers:
# - Implement Redis-backed session store (SESSIONS dict replacement)
# - Use redis-py with connection pooling
# - Session operations become: SET/GET/DEL with TTL on Redis keys
# - This enables horizontal scaling with --workers N
#
echo "Starting Gunicorn on TCP :8080..."

# Gunicorn timeout should exceed upstream read timeout (GATEWAY_READ_TIMEOUT, default 600s)
# to prevent workers from being killed mid-request during large git operations
GUNICORN_TIMEOUT="${GATEWAY_GUNICORN_TIMEOUT:-660}"

# If running as root, drop privileges to appuser for Gunicorn
# This provides defense-in-depth: dnsmasq runs as root (for port 53),
# but the main application runs as non-root
if [ "$(id -u)" -eq 0 ] && command -v gosu >/dev/null 2>&1; then
    echo "Dropping privileges to user: ${RUN_USER}"
    exec gosu "${RUN_USER}" gunicorn \
        --bind "0.0.0.0:8080" \
        --workers 1 \
        --worker-class sync \
        --timeout "${GUNICORN_TIMEOUT}" \
        --access-logfile - \
        --error-logfile - \
        --capture-output \
        gateway:app
else
    exec gunicorn \
        --bind "0.0.0.0:8080" \
        --workers 1 \
        --worker-class sync \
        --timeout "${GUNICORN_TIMEOUT}" \
        --access-logfile - \
        --error-logfile - \
        --capture-output \
        gateway:app
fi
