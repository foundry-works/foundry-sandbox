#!/bin/bash
# Entrypoint script for credential isolation gateway
# Starts dnsmasq for DNS routing (as root) and Gunicorn bound to both TCP and Unix socket (as appuser)
#
# SECURITY: Implements startup synchronization barrier to ensure firewall rules
# are applied before accepting any connections.

set -e

# Create Unix socket directory with proper permissions
SOCKET_DIR="/var/run/gateway"
SOCKET_PATH="${SOCKET_DIR}/gateway.sock"
READY_FILE="${SOCKET_DIR}/.ready"
RUN_USER="${GATEWAY_USER:-appuser}"

echo "Creating socket directory: ${SOCKET_DIR}"
# Use install -d for atomic directory creation with proper permissions
# This prevents race conditions between mkdir and chmod
if [ "$(id -u)" -eq 0 ]; then
    install -d -m 755 -o "${RUN_USER}" -g "${RUN_USER}" "${SOCKET_DIR}"
else
    # Non-root: create with umask and hope for the best
    mkdir -p "${SOCKET_DIR}"
    chmod 755 "${SOCKET_DIR}"
fi

# Start dnsmasq for DNS routing (if configured)
# This allows the gateway to control DNS resolution for sandboxed containers
# dnsmasq binds to port 53 as root, then drops privileges to appuser
# via the user= and group= directives in dnsmasq.conf (generated by build-configs.sh)
if [ -f /etc/dnsmasq.conf ] && [ "${GATEWAY_ENABLE_DNS:-false}" = "true" ]; then
    if [ "$(id -u)" -eq 0 ]; then
        echo "Starting dnsmasq for DNS routing..."
        dnsmasq --keep-in-foreground &
        DNSMASQ_PID=$!
        echo "dnsmasq started with PID: ${DNSMASQ_PID}"
    else
        echo "WARNING: dnsmasq requires root privileges to bind port 53, skipping DNS routing"
        echo "To enable DNS routing, run the container with GATEWAY_ENABLE_DNS=true and as root"
    fi
else
    echo "DNS routing disabled (set GATEWAY_ENABLE_DNS=true to enable)"
fi

# Cleanup function for graceful shutdown
cleanup() {
    echo "Shutting down gateway services..."

    # Stop dnsmasq if running
    if [ -n "${DNSMASQ_PID:-}" ] && kill -0 "${DNSMASQ_PID}" 2>/dev/null; then
        echo "Stopping dnsmasq (PID: ${DNSMASQ_PID})..."
        kill -TERM "${DNSMASQ_PID}" 2>/dev/null || true
        wait "${DNSMASQ_PID}" 2>/dev/null || true
    fi

    # Remove socket file
    if [ -S "${SOCKET_PATH}" ]; then
        echo "Removing socket file: ${SOCKET_PATH}"
        rm -f "${SOCKET_PATH}"
    fi

    # Remove ready file
    if [ -f "${READY_FILE}" ]; then
        rm -f "${READY_FILE}"
    fi

    echo "Gateway shutdown complete"
    exit 0
}

# Register cleanup handler for graceful shutdown
trap cleanup SIGTERM SIGINT SIGQUIT

# ==============================================================================
# SECURITY: Startup Synchronization Barrier
# ==============================================================================
# Ensure firewall rules are applied BEFORE accepting any connections.
# This prevents a race condition where malicious code could exfiltrate data
# during the startup window before iptables rules are in place.
#
# The firewall script (if run externally) should create the ready file.
# If running in standalone mode, we apply basic rules here.
# ==============================================================================

apply_startup_firewall() {
    echo "Applying startup firewall rules..."

    # Check if we have iptables capability
    if ! command -v iptables &>/dev/null; then
        echo "WARNING: iptables not available, skipping firewall rules"
        return 0
    fi

    # Check if we have NET_ADMIN capability (required for iptables)
    if ! iptables -L OUTPUT -n &>/dev/null 2>&1; then
        echo "WARNING: Cannot access iptables (missing NET_ADMIN?), skipping firewall rules"
        return 0
    fi

    # Apply minimal firewall rules for the gateway container itself:
    # - Allow loopback
    # - Allow established connections
    # - Allow outbound to GitHub (for proxying git requests)
    # The sandbox firewall (network-firewall.sh) provides the main isolation

    # Only apply if OUTPUT chain is empty (avoid double application)
    local rule_count
    rule_count=$(iptables -L OUTPUT -n 2>/dev/null | wc -l)
    if [ "$rule_count" -gt 2 ]; then
        echo "Firewall rules already applied (${rule_count} rules in OUTPUT)"
        return 0
    fi

    echo "  - Allowing loopback and established connections"
    iptables -A OUTPUT -o lo -j ACCEPT 2>/dev/null || true
    iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT 2>/dev/null || true

    echo "Firewall rules applied successfully"
    return 0
}

# Apply firewall rules before starting any services
apply_startup_firewall

# Create ready file to signal firewall is configured
# Other containers can wait for this file before sending requests
touch "${READY_FILE}" 2>/dev/null || true
echo "Gateway firewall barrier complete, ready file created: ${READY_FILE}"

# Start Gunicorn bound to BOTH TCP port and Unix socket
# - TCP 8080: For external HTTP traffic (git operations)
# - Unix socket: For local session management (create/destroy)
#
# IMPORTANT: Single-Worker Architecture Constraint
# ================================================
# The gateway uses --workers 1 because session state is stored in an
# in-memory Python dict (SESSIONS). Multiple workers would each have
# their own separate dict, causing session validation failures when
# requests land on different workers than where the session was created.
#
# Performance implications:
# - Single worker handles all requests sequentially (sync worker class)
# - Long-running git operations (clone, push) block other requests
# - Sufficient for sandbox environments with limited concurrent containers
#
# For high-scale deployments requiring multiple workers:
# - Implement Redis-backed session store (SESSIONS dict replacement)
# - Use redis-py with connection pooling
# - Session operations become: SET/GET/DEL with TTL on Redis keys
# - This enables horizontal scaling with --workers N
#
echo "Starting Gunicorn on TCP :8080 and Unix socket ${SOCKET_PATH}..."

# Gunicorn timeout should exceed upstream read timeout (GATEWAY_READ_TIMEOUT, default 600s)
# to prevent workers from being killed mid-request during large git operations
GUNICORN_TIMEOUT="${GATEWAY_GUNICORN_TIMEOUT:-660}"

# If running as root, drop privileges to appuser for Gunicorn
# This provides defense-in-depth: dnsmasq runs as root (for port 53),
# but the main application runs as non-root
if [ "$(id -u)" -eq 0 ] && command -v gosu >/dev/null 2>&1; then
    echo "Dropping privileges to user: ${RUN_USER}"
    exec gosu "${RUN_USER}" gunicorn \
        --bind "0.0.0.0:8080" \
        --bind "unix:${SOCKET_PATH}" \
        --workers 1 \
        --worker-class sync \
        --timeout "${GUNICORN_TIMEOUT}" \
        --access-logfile - \
        --error-logfile - \
        --capture-output \
        gateway:app
else
    exec gunicorn \
        --bind "0.0.0.0:8080" \
        --bind "unix:${SOCKET_PATH}" \
        --workers 1 \
        --worker-class sync \
        --timeout "${GUNICORN_TIMEOUT}" \
        --access-logfile - \
        --error-logfile - \
        --capture-output \
        gateway:app
fi
