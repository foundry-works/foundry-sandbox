# Credential Isolation Override
#
# Use with: docker-compose -f docker-compose.yml -f docker-compose.credential-isolation.yml up
#
# This override:
# 1. Adds gateway service for Git credential isolation
# 2. Adds api-proxy service that holds API credentials
# 3. Configures dev service to route traffic through the proxies
# 4. Removes credentials from dev service environment
#
# Requires: GITHUB_TOKEN and API keys passed via environment variables

services:
    # Git Gateway - holds GitHub credentials, proxies git operations
    # Sandboxes authenticate with session tokens, gateway injects real credentials
    gateway:
        build:
            context: ./gateway
        image: credential-isolation-gateway

        # Drop dangerous capabilities for defense-in-depth
        # NET_RAW prevents IP spoofing and raw packet crafting
        # NET_ADMIN prevents routing table manipulation via netlink sockets
        # Note: dnsmasq may need NET_RAW for some DNS features, but core
        # functionality works without it. If DNS issues occur, review this.
        cap_drop:
            - NET_RAW
            - NET_ADMIN

        # Read-only root filesystem for defense-in-depth
        # If compromised, attacker cannot persist changes to the filesystem
        read_only: true

        # Tmpfs mounts for writable directories needed at runtime
        tmpfs:
            - /tmp:size=64M,mode=1777
            - /run:size=16M,mode=755

        # GitHub credentials (passed from host environment)
        environment:
            - GITHUB_TOKEN
            - GATEWAY_PORT=8080
            - GATEWAY_HOST=0.0.0.0
            # Enable DNS routing - required for proper credential isolation
            # Without this, sandboxes can bypass the gateway using hardcoded IPs
            - GATEWAY_ENABLE_DNS=true
            # Session management API key (for TCP-based session management from host)
            - GATEWAY_SESSION_MGMT_KEY

        # Expose gateway port to localhost for host session management
        # Port is dynamically assigned and stored in GATEWAY_HOST_PORT env var
        ports:
            - "127.0.0.1:${GATEWAY_HOST_PORT:-0}:8080"

        # SECURITY: gateway on credential-isolation (internal) + proxy-egress (external)
        # - credential-isolation: internal network for sandbox communication
        # - proxy-egress: allows outbound git operations to github.com
        #
        # Gateway needs external access to proxy git requests to github.com.
        networks:
            credential-isolation:
                aliases:
                    - gateway-dns
            proxy-egress: {}

        # Container always restarts unless explicitly stopped
        restart: unless-stopped

        # Healthcheck - verify gateway is responding
        healthcheck:
            test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
            interval: 10s
            timeout: 5s
            retries: 3
            start_period: 10s

    # API Proxy - holds credentials, injects into API requests
    api-proxy:
        build:
            context: ./api-proxy
        image: foundry-api-proxy

        # Drop dangerous capabilities for defense-in-depth
        cap_drop:
            - NET_RAW
            - NET_ADMIN

        # API credentials (passed from host environment)
        environment:
            - CLAUDE_CODE_OAUTH_TOKEN
            - ANTHROPIC_API_KEY
            # OPENAI_API_KEY removed - Codex uses OAuth via CODEX_AUTH_FILE instead
            - GOOGLE_API_KEY
            - GEMINI_API_KEY
            - TAVILY_API_KEY
            - SEMANTIC_SCHOLAR_API_KEY
            - PERPLEXITY_API_KEY
            - ZHIPU_API_KEY
            - PROXY_MODE=regular
            - PROXY_LOG_LEVEL=${PROXY_LOG_LEVEL:-info}
            # OAuth support for Codex CLI
            - CODEX_AUTH_FILE=/credentials/codex/auth.json
            # OAuth support for OpenCode CLI
            - OPENCODE_AUTH_FILE=/credentials/opencode/auth.json
            # OAuth support for Gemini CLI
            - GEMINI_OAUTH_FILE=/credentials/gemini/oauth_creds.json

        volumes:
            # Shared certificate volume - proxy writes CA, sandbox reads it
            - mitm-certs:/etc/proxy/certs
            # Codex OAuth credentials (mount specific file only)
            - ${HOME}/.codex/auth.json:/credentials/codex/auth.json:ro
            # OpenCode OAuth credentials (mount specific file only)
            - ${HOME}/.local/share/opencode/auth.json:/credentials/opencode/auth.json:ro
            # Gemini OAuth credentials (mount specific file only)
            - ${HOME}/.gemini/oauth_creds.json:/credentials/gemini/oauth_creds.json:ro
            # Hostname allowlist for egress filtering (shared with gateway)
            - ./gateway/firewall-allowlist.generated:/gateway/firewall-allowlist.generated:ro

        # SECURITY: api-proxy on credential-isolation (internal) + proxy-egress (external)
        # - credential-isolation: internal network for sandbox communication
        # - proxy-egress: allows outbound API calls but is separate from 'default'
        #
        # This prevents credential exfiltration via the default network while still
        # allowing the proxy to reach external APIs through a dedicated egress path.
        networks:
            credential-isolation: {}
            proxy-egress: {}

        # Container always restarts unless explicitly stopped
        restart: unless-stopped

        # Healthcheck - verify proxy port is listening
        healthcheck:
            test:
                [
                    "CMD",
                    "python3",
                    "-c",
                    "import socket; s=socket.socket(); s.settimeout(2); s.connect(('localhost', 8080)); s.close()",
                ]
            interval: 5s
            timeout: 5s
            retries: 5
            start_period: 10s

    # Dev service overrides for credential isolation
    # Sandbox container - only on internal network, no direct external access
    dev:
        depends_on:
            api-proxy:
                condition: service_healthy
            gateway:
                condition: service_healthy

        # Start as root to configure DNS (read-only filesystem), then drop to sandbox user
        # The entrypoint-root.sh resolves 'gateway' IP dynamically and writes /etc/resolv.conf
        # This allows multiple sandboxes to run simultaneously (no static IP conflicts)
        user: root
        entrypoint: ["/usr/local/bin/entrypoint-root.sh"]

        volumes:
            # Mount shared certificate volume (read-only for sandbox)
            - mitm-certs:/certs:ro
            # Proxy stub files from named volume (populated by populate_stubs_volume)
            # Uses volume instead of bind mounts to avoid Docker Desktop VirtioFS staleness
            - proxy-stubs:/etc/proxy-stubs:ro

        networks:
            - credential-isolation

        # Override read_only from base compose - required for DNS configuration
        # Security is maintained by network isolation (internal: true) which prevents
        # external access. The sandbox cannot exfiltrate data or access credentials.
        read_only: false

        # NET_ADMIN required for iptables DNS firewall rules in entrypoint-root.sh
        # Rules are set up before dropping privileges to sandbox user
        cap_add:
            - NET_ADMIN

        # Drop NET_RAW capability to prevent IP spoofing, ARP poisoning, and packet sniffing
        # This is critical for supply chain attack protection - malicious packages cannot
        # craft raw packets to bypass network isolation (ICC=false)
        cap_drop:
            - NET_RAW

        # Note: no-new-privileges would be ideal but conflicts with gosu privilege dropping
        # Security is maintained by network isolation (internal: true network)

        # Note: /proc/kcore masking would require SYS_ADMIN capability which is too
        # dangerous. Network isolation (internal: true) is the primary security boundary.
        # /proc/kcore access is defense-in-depth; the sandbox cannot exfiltrate data anyway.

        environment:
            # Enable gateway mode - rewrites git URLs to route through credential isolation gateway
            - SANDBOX_GATEWAY_ENABLED=true
            # Explicit proxy config for outbound API traffic
            - HTTP_PROXY=http://api-proxy:8080
            - HTTPS_PROXY=http://api-proxy:8080
            - NO_PROXY=localhost,127.0.0.1,api-proxy,gateway
            # Trust the mitmproxy CA certificate for HTTPS interception
            - NODE_EXTRA_CA_CERTS=/certs/mitmproxy-ca.pem
            - REQUESTS_CA_BUNDLE=/certs/mitmproxy-ca.pem
            - SSL_CERT_FILE=/certs/mitmproxy-ca.pem
            - CURL_CA_BUNDLE=/certs/mitmproxy-ca.pem

            # Force Node.js apps to use proxy (global-agent bootstrap)
            # Note: NODE_USE_ENV_PROXY=1 was tested but breaks some apps and doesn't help HTTP/2
            - NODE_OPTIONS=--require /usr/lib/node_modules/global-agent/bootstrap.js
            - GLOBAL_AGENT_HTTP_PROXY=http://api-proxy:8080
            - GLOBAL_AGENT_HTTPS_PROXY=http://api-proxy:8080
            - GLOBAL_AGENT_NO_PROXY=localhost,127.0.0.1,api-proxy,gateway

            # CRITICAL: Unset GitHub tokens - dev must NOT have direct GitHub access
            # Git operations go through gateway which holds the real credentials
            - GITHUB_TOKEN=
            - GH_TOKEN=

            # Placeholder API keys - tools see these as "authenticated"
            # Proxy intercepts requests and injects real credentials
            # Claude and Gemini use conditional placeholders based on host auth config:
            # - If host uses OAuth, sandbox gets OAuth placeholder (not API key)
            # - If host uses API key, sandbox gets API key placeholder
            # This is set by setup_credential_placeholders() in lib/docker.sh
            - ANTHROPIC_API_KEY=${SANDBOX_ANTHROPIC_API_KEY:-}
            - CLAUDE_CODE_OAUTH_TOKEN=${SANDBOX_CLAUDE_OAUTH:-}
            - OPENAI_API_KEY=CREDENTIAL_PROXY_PLACEHOLDER
            - GOOGLE_API_KEY=CREDENTIAL_PROXY_PLACEHOLDER
            - GEMINI_API_KEY=${SANDBOX_GEMINI_API_KEY:-}
            - TAVILY_API_KEY=CREDENTIAL_PROXY_PLACEHOLDER
            - SEMANTIC_SCHOLAR_API_KEY=CREDENTIAL_PROXY_PLACEHOLDER
            - PERPLEXITY_API_KEY=CREDENTIAL_PROXY_PLACEHOLDER
            - ZHIPU_API_KEY=PROXY_PLACEHOLDER_OPENCODE

            # Keep non-credential env vars from base compose
            # (they're inherited, but listing here for clarity)
            # - CLAUDE_CONFIG_DIR
            # - CLAUDE_CODE_TMPDIR
            # - etc.

# Isolated network for credential proxy communication
# - internal: true = no external network access
# - ICC enabled = containers can communicate (required for dev -> gateway/proxy)
# Note: Each sandbox project has its own isolated network, so ICC doesn't
# compromise isolation between different sandboxes.
networks:
    credential-isolation:
        driver: bridge
        internal: true

    # Dedicated egress network for gateway and api-proxy
    # Allows outbound connections to external APIs (github.com, api.anthropic.com, etc.)
    # Separate from 'default' to limit attack surface if proxy is compromised
    proxy-egress:
        driver: bridge
        # NOT internal - allows outbound connections
        # No ICC needed since only gateway and api-proxy use this network

# Shared volumes
volumes:
    # mitmproxy CA certificate (api-proxy writes, sandbox reads)
    mitm-certs:
    # Stubs volume (pre-created by populate_stubs_volume before compose up)
    # External volume avoids Docker Desktop bind mount staleness issues
    proxy-stubs:
        name: ${STUBS_VOLUME_NAME:-proxy-stubs}
        external: true
    # Note: gateway-socket is now a bind mount (not a named volume)
    # to allow host access for session management
