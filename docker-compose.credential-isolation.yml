# Credential Isolation Override
#
# Use with: docker-compose -f docker-compose.yml -f docker-compose.credential-isolation.yml up
#
# This override:
# 1. Adds gateway service for Git credential isolation
# 2. Adds api-proxy service that holds API credentials
# 3. Configures dev service to route traffic through the proxies
# 4. Removes credentials from dev service environment
#
# Requires: GITHUB_TOKEN and API keys passed via environment variables

services:
  # Git Gateway - holds GitHub credentials, proxies git operations
  # Sandboxes authenticate with session tokens, gateway injects real credentials
  gateway:
    build:
      context: ./gateway
    image: credential-isolation-gateway

    # Drop dangerous capabilities for defense-in-depth
    # NET_RAW prevents IP spoofing and raw packet crafting
    # NET_ADMIN prevents routing table manipulation via netlink sockets
    # Note: dnsmasq may need NET_RAW for some DNS features, but core
    # functionality works without it. If DNS issues occur, review this.
    cap_drop:
      - NET_RAW
      - NET_ADMIN

    # Read-only root filesystem for defense-in-depth
    # If compromised, attacker cannot persist changes to the filesystem
    read_only: true

    # Tmpfs mounts for writable directories needed at runtime
    tmpfs:
      - /tmp:size=64M,mode=1777
      - /run:size=16M,mode=755

    # GitHub credentials (passed from host environment)
    environment:
      - GITHUB_TOKEN
      - GATEWAY_PORT=8080
      - GATEWAY_HOST=0.0.0.0
      # Enable DNS routing - required for proper credential isolation
      # Without this, sandboxes can bypass the gateway using hardcoded IPs
      - GATEWAY_ENABLE_DNS=true
      # Session management API key (for TCP-based session management from host)
      - GATEWAY_SESSION_MGMT_KEY

    # Expose gateway port to localhost for host session management
    # Port is dynamically assigned and stored in GATEWAY_HOST_PORT env var
    ports:
      - "127.0.0.1:${GATEWAY_HOST_PORT:-0}:8080"

    # SECURITY: gateway on credential-isolation (internal) + proxy-egress (external)
    # - credential-isolation: internal network for sandbox communication
    # - proxy-egress: allows outbound git operations to github.com
    #
    # Gateway needs external access to proxy git requests to github.com.
    networks:
      credential-isolation:
        aliases:
          - gateway-dns
      proxy-egress: {}

    # Container always restarts unless explicitly stopped
    restart: unless-stopped

    # Healthcheck - verify gateway is responding
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
      interval: 10s
      timeout: 5s
      retries: 3
      start_period: 10s

  # API Proxy - holds credentials, injects into API requests
  api-proxy:
    build:
      context: ./api-proxy
    image: foundry-api-proxy

    # Drop dangerous capabilities for defense-in-depth
    cap_drop:
      - NET_RAW
      - NET_ADMIN

    # API credentials (passed from host environment)
    environment:
      - CLAUDE_CODE_OAUTH_TOKEN
      - ANTHROPIC_API_KEY
      - OPENAI_API_KEY
      - GOOGLE_API_KEY
      - GEMINI_API_KEY
      - GROQ_API_KEY
      - MISTRAL_API_KEY
      - DEEPSEEK_API_KEY
      - TOGETHER_API_KEY
      - OPENROUTER_API_KEY
      - FIREWORKS_API_KEY
      - TAVILY_API_KEY
      - SEMANTIC_SCHOLAR_API_KEY
      - PERPLEXITY_API_KEY
      - CURSOR_API_KEY
      - PROXY_MODE=regular
      - PROXY_LOG_LEVEL=${PROXY_LOG_LEVEL:-info}
      # OAuth support for Codex CLI
      - CODEX_AUTH_FILE=/credentials/codex/auth.json
      # OAuth support for OpenCode CLI
      - OPENCODE_AUTH_FILE=/credentials/opencode/auth.json
      # OAuth support for Gemini CLI
      - GEMINI_OAUTH_FILE=/credentials/gemini/oauth_creds.json

    volumes:
      # Shared certificate volume - proxy writes CA, sandbox reads it
      - mitm-certs:/etc/proxy/certs
      # Codex OAuth credentials (mount specific file only)
      - ${HOME}/.codex/auth.json:/credentials/codex/auth.json:ro
      # OpenCode OAuth credentials (mount specific file only)
      - ${HOME}/.local/share/opencode/auth.json:/credentials/opencode/auth.json:ro
      # Gemini OAuth credentials (mount specific file only)
      - ${HOME}/.gemini/oauth_creds.json:/credentials/gemini/oauth_creds.json:ro

    # SECURITY: api-proxy on credential-isolation (internal) + proxy-egress (external)
    # - credential-isolation: internal network for sandbox communication
    # - proxy-egress: allows outbound API calls but is separate from 'default'
    #
    # This prevents credential exfiltration via the default network while still
    # allowing the proxy to reach external APIs through a dedicated egress path.
    networks:
      credential-isolation: {}
      proxy-egress: {}

    # Container always restarts unless explicitly stopped
    restart: unless-stopped

    # Healthcheck - verify proxy port is listening
    healthcheck:
      test: ["CMD", "python3", "-c", "import socket; s=socket.socket(); s.settimeout(2); s.connect(('localhost', 8080)); s.close()"]
      interval: 5s
      timeout: 5s
      retries: 5
      start_period: 10s

  # Dev service overrides for credential isolation
  # Sandbox container - only on internal network, no direct external access
  dev:
    depends_on:
      api-proxy:
        condition: service_healthy
      gateway:
        condition: service_healthy

    # DNS is configured dynamically at container startup via entrypoint
    # The entrypoint resolves 'gateway' to its IP and sets /etc/resolv.conf
    # This allows multiple sandboxes to run simultaneously (no static IP conflicts)

    volumes:
      # Mount shared certificate volume (read-only for sandbox)
      - mitm-certs:/certs:ro
      # Proxy stub files mounted to neutral system location
      # Entrypoint symlinks these to user directories to avoid Docker creating root-owned parent dirs
      - ./api-proxy/stub-auth-codex.json:/etc/proxy-stubs/codex-auth.json:ro
      - ./api-proxy/stub-auth-opencode.json:/etc/proxy-stubs/opencode-auth.json:ro
      - ./api-proxy/stub-opencode-config.json:/etc/proxy-stubs/opencode-config.json:ro
      - ./api-proxy/stub-auth-gemini.json:/etc/proxy-stubs/gemini-oauth.json:ro
      - ./api-proxy/stub-gemini-accounts.json:/etc/proxy-stubs/gemini-accounts.json:ro
      - ./api-proxy/stub-gemini-settings.json:/etc/proxy-stubs/gemini-settings.json:ro

    networks:
      - credential-isolation

    # Drop NET_RAW capability to prevent IP spoofing, ARP poisoning, and packet sniffing
    # This is critical for supply chain attack protection - malicious packages cannot
    # craft raw packets to bypass network isolation (ICC=false)
    cap_drop:
      - NET_RAW

    environment:
      # Enable gateway mode - rewrites git URLs to route through credential isolation gateway
      - SANDBOX_GATEWAY_ENABLED=true
      # Explicit proxy config for outbound API traffic
      - HTTP_PROXY=http://api-proxy:8080
      - HTTPS_PROXY=http://api-proxy:8080
      - NO_PROXY=localhost,127.0.0.1,api-proxy,gateway
      # Trust the mitmproxy CA certificate for HTTPS interception
      - NODE_EXTRA_CA_CERTS=/certs/mitmproxy-ca.pem
      - REQUESTS_CA_BUNDLE=/certs/mitmproxy-ca.pem
      - SSL_CERT_FILE=/certs/mitmproxy-ca.pem
      - CURL_CA_BUNDLE=/certs/mitmproxy-ca.pem

      # CRITICAL: Unset GitHub tokens - dev must NOT have direct GitHub access
      # Git operations go through gateway which holds the real credentials
      - GITHUB_TOKEN=
      - GH_TOKEN=

      # Placeholder API keys - tools see these as "authenticated"
      # Proxy intercepts requests and injects real credentials
      # Claude and Gemini use conditional placeholders based on host auth config:
      # - If host uses OAuth, sandbox gets OAuth placeholder (not API key)
      # - If host uses API key, sandbox gets API key placeholder
      # This is set by setup_credential_placeholders() in lib/docker.sh
      - ANTHROPIC_API_KEY=${SANDBOX_ANTHROPIC_API_KEY:-}
      - CLAUDE_CODE_OAUTH_TOKEN=${SANDBOX_CLAUDE_OAUTH:-}
      - OPENAI_API_KEY=CREDENTIAL_PROXY_PLACEHOLDER
      - GOOGLE_API_KEY=CREDENTIAL_PROXY_PLACEHOLDER
      - GEMINI_API_KEY=${SANDBOX_GEMINI_API_KEY:-}
      - GROQ_API_KEY=CREDENTIAL_PROXY_PLACEHOLDER
      - MISTRAL_API_KEY=CREDENTIAL_PROXY_PLACEHOLDER
      - DEEPSEEK_API_KEY=CREDENTIAL_PROXY_PLACEHOLDER
      - TOGETHER_API_KEY=CREDENTIAL_PROXY_PLACEHOLDER
      - OPENROUTER_API_KEY=CREDENTIAL_PROXY_PLACEHOLDER
      - FIREWORKS_API_KEY=CREDENTIAL_PROXY_PLACEHOLDER
      - TAVILY_API_KEY=CREDENTIAL_PROXY_PLACEHOLDER
      - SEMANTIC_SCHOLAR_API_KEY=CREDENTIAL_PROXY_PLACEHOLDER
      - PERPLEXITY_API_KEY=CREDENTIAL_PROXY_PLACEHOLDER
      - CURSOR_API_KEY=CREDENTIAL_PROXY_PLACEHOLDER

      # Keep non-credential env vars from base compose
      # (they're inherited, but listing here for clarity)
      # - CLAUDE_CONFIG_DIR
      # - CLAUDE_CODE_TMPDIR
      # - etc.

# Isolated network for credential proxy communication
# - internal: true = no external network access
# - ICC enabled = containers can communicate (required for dev -> gateway/proxy)
# Note: Each sandbox project has its own isolated network, so ICC doesn't
# compromise isolation between different sandboxes.
networks:
  credential-isolation:
    driver: bridge
    internal: true

  # Dedicated egress network for gateway and api-proxy
  # Allows outbound connections to external APIs (github.com, api.anthropic.com, etc.)
  # Separate from 'default' to limit attack surface if proxy is compromised
  proxy-egress:
    driver: bridge
    # NOT internal - allows outbound connections
    # No ICC needed since only gateway and api-proxy use this network

# Shared volumes
volumes:
  # mitmproxy CA certificate (api-proxy writes, sandbox reads)
  mitm-certs:
  # Note: gateway-socket is now a bind mount (not a named volume)
  # to allow host access for session management
